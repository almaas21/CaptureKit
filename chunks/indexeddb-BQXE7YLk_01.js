const b="ScreenRecorderDB";const i="media",l="projects",d="videos";function u(){return new Promise((o,t)=>{const n=indexedDB.open(b,2);n.onupgradeneeded=c=>{const e=c.target.result;e.objectStoreNames.contains(d)||e.createObjectStore(d,{keyPath:"id"}),e.objectStoreNames.contains(i)||e.createObjectStore(i,{keyPath:"id"}),e.objectStoreNames.contains(l)||e.createObjectStore(l,{keyPath:"id"})},n.onsuccess=()=>o(n.result),n.onerror=()=>t(n.error)})}async function g(){const o=await u();if(!o.objectStoreNames.contains(d)){o.close();return}const t=await new Promise((e,r)=>{const a=o.transaction(d,"readonly").objectStore(d).getAll();a.onsuccess=()=>e(a.result||[]),a.onerror=()=>r(a.error)});if(t.length===0){o.close();return}const n=new Set(await new Promise((e,r)=>{const a=o.transaction(i,"readonly").objectStore(i).getAllKeys();a.onsuccess=()=>e((a.result||[]).map(String)),a.onerror=()=>r(a.error)})),c=t.filter(e=>!n.has(e.id));if(c.length===0){o.close();return}await new Promise((e,r)=>{const s=o.transaction(i,"readwrite"),m=s.objectStore(i);for(const a of c){const S={id:a.id,name:`Recording ${new Date(a.createdAt||Date.now()).toLocaleString()}`,type:"video",blob:a.blob,duration:a.recordedDuration||a.duration||0,source:"recording",createdAt:a.createdAt||new Date().toISOString()};m.put(S)}s.oncomplete=()=>e(),s.onerror=()=>r(s.error)}),o.close()}async function f(){const o=await u();return new Promise((t,n)=>{const r=o.transaction(i,"readonly").objectStore(i).getAll();r.onsuccess=()=>{o.close(),t(r.result||[])},r.onerror=()=>{o.close(),n(r.error)}})}async function y(o){const t=await u();return new Promise((n,c)=>{const e=t.transaction(i,"readwrite");e.objectStore(i).put(o),e.oncomplete=()=>{t.close(),n()},e.onerror=()=>{t.close(),c(e.error)}})}async function p(o){const t=await u(),n=[i];return t.objectStoreNames.contains(d)&&n.push(d),new Promise((c,e)=>{const r=t.transaction(n,"readwrite");r.objectStore(i).delete(o),t.objectStoreNames.contains(d)&&r.objectStore(d).delete(o),r.oncomplete=()=>{t.close(),c()},r.onerror=()=>{t.close(),e(r.error)}})}async function P(){const o=await u();return new Promise((t,n)=>{const r=o.transaction(l,"readonly").objectStore(l).getAll();r.onsuccess=()=>{o.close(),t(r.result||[])},r.onerror=()=>{o.close(),n(r.error)}})}async function x(o){const t=await u();return new Promise((n,c)=>{const s=t.transaction(l,"readonly").objectStore(l).get(o);s.onsuccess=()=>{t.close(),n(s.result||null)},s.onerror=()=>{t.close(),c(s.error)}})}async function D(o){const t=await u();return new Promise((n,c)=>{const e=t.transaction(l,"readwrite");e.objectStore(l).put(o),e.oncomplete=()=>{t.close(),n()},e.onerror=()=>{t.close(),c(e.error)}})}async function R(o){const t=await u();return new Promise((n,c)=>{const e=t.transaction(l,"readwrite");e.objectStore(l).delete(o),e.oncomplete=()=>{t.close(),n()},e.onerror=()=>{t.close(),c(e.error)}})}async function A(o,t,n,c){const e=Date.now().toString();if(!n||!c)try{const m=await j(o);n=m.width,c=m.height}catch{}const r={id:e,name:`Recording ${new Date().toLocaleString()}`,type:"video",blob:o,duration:t,width:n,height:c,source:"recording",createdAt:new Date().toISOString()},s=await u();return await new Promise((m,a)=>{const S=[i];s.objectStoreNames.contains(d)&&S.push(d);const w=s.transaction(S,"readwrite");w.objectStore(i).put(r),s.objectStoreNames.contains(d)&&w.objectStore(d).put({id:e,blob:o,duration:t,recordedDuration:t,createdAt:r.createdAt}),w.oncomplete=()=>{s.close(),m()},w.onerror=()=>{s.close(),a(w.error)}}),e}function j(o){return new Promise((t,n)=>{const c=URL.createObjectURL(o),e=document.createElement("video");e.preload="metadata",e.onloadedmetadata=()=>{const r=e.videoWidth,s=e.videoHeight;URL.revokeObjectURL(c),e.remove(),r>0&&s>0?t({width:r,height:s}):n(new Error("Could not determine dimensions"))},e.onerror=()=>{URL.revokeObjectURL(c),e.remove(),n(new Error("Video load error"))},e.src=c})}export{p as deleteMedia,R as deleteProject,f as getAllMedia,P as getAllProjects,x as getProjectById,g as migrateFromLegacyStore,y as saveMedia,D as saveProject,A as saveRecording};